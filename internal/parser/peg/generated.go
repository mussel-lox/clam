// Code generated by pigeon; DO NOT EDIT.

package peg

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"math"
	"os"
	"sort"
	"strconv"
	"strings"
	"sync"
	"unicode"
	"unicode/utf8"

	"github.com/mussel-lox/clam/ast"
)

const (
	TokLeftParenthesis TokenKind = iota
	TokRightParenthesis
	TokLeftBrace
	TokRightBrace
	TokComma
	TokDot
	TokMinus
	TokPlus
	TokSemicolon
	TokSlash
	TokStar
	TokBang
	TokBangEqual
	TokEqual
	TokEqualEqual
	TokGreater
	TokGreaterEqual
	TokLess
	TokLessEqual
	TokAnd
	TokClass
	TokElse
	TokFalse
	TokFor
	TokFun
	TokIf
	TokNil
	TokOr
	TokPrint
	TokReturn
	TokSuper
	TokThis
	TokTrue
	TokVar
	TokWhile
)

type TokenKind int

func matchedTextOf(c *current) string {
	return strings.TrimSpace(string(c.text))
}

func recursiveResolveExpressions(a any) []ast.Expression {
	var exprs []ast.Expression
	switch arg := a.(type) {
	case ast.Expression:
		exprs = append(exprs, arg)
	case []any:
		for _, element := range arg {
			e := recursiveResolveExpressions(element)
			if e != nil {
				exprs = append(exprs, e...)
			}
		}
	}
	return exprs
}

func recursiveResolveIdentifiers(a any) []ast.Identifier {
	var idents []ast.Identifier
	switch arg := a.(type) {
	case ast.Identifier:
		idents = append(idents, arg)
	case []any:
		for _, element := range arg {
			i := recursiveResolveIdentifiers(element)
			if i != nil {
				idents = append(idents, i...)
			}
		}
	}
	return idents
}

var g = &grammar{
	rules: []*rule{
		{
			name:        "_",
			displayName: "\"WHITESPACES\"",
			pos:         position{line: 96, col: 1, offset: 1635},
			expr: &zeroOrMoreExpr{
				pos: position{line: 96, col: 19, offset: 1653},
				expr: &charClassMatcher{
					pos:        position{line: 96, col: 19, offset: 1653},
					val:        "[ \\t\\r\\n]",
					chars:      []rune{' ', '\t', '\r', '\n'},
					ignoreCase: false,
					inverted:   false,
				},
			},
		},
		{
			name: "ALPHA",
			pos:  position{line: 98, col: 1, offset: 1667},
			expr: &charClassMatcher{
				pos:        position{line: 98, col: 9, offset: 1675},
				val:        "[a-zA-Z_]",
				chars:      []rune{'_'},
				ranges:     []rune{'a', 'z', 'A', 'Z'},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "DIGIT",
			pos:  position{line: 99, col: 1, offset: 1686},
			expr: &charClassMatcher{
				pos:        position{line: 99, col: 9, offset: 1694},
				val:        "[0-9]",
				ranges:     []rune{'0', '9'},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "IDENTIFIER",
			pos:  position{line: 101, col: 1, offset: 1703},
			expr: &actionExpr{
				pos: position{line: 101, col: 14, offset: 1716},
				run: (*parser).callonIDENTIFIER1,
				expr: &seqExpr{
					pos: position{line: 101, col: 14, offset: 1716},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 101, col: 14, offset: 1716},
							name: "_",
						},
						&ruleRefExpr{
							pos:  position{line: 101, col: 16, offset: 1718},
							name: "ALPHA",
						},
						&zeroOrMoreExpr{
							pos: position{line: 101, col: 22, offset: 1724},
							expr: &choiceExpr{
								pos: position{line: 101, col: 24, offset: 1726},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 101, col: 24, offset: 1726},
										name: "ALPHA",
									},
									&ruleRefExpr{
										pos:  position{line: 101, col: 32, offset: 1734},
										name: "DIGIT",
									},
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 101, col: 41, offset: 1743},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "STRING",
			pos:  position{line: 106, col: 1, offset: 1813},
			expr: &actionExpr{
				pos: position{line: 106, col: 10, offset: 1822},
				run: (*parser).callonSTRING1,
				expr: &seqExpr{
					pos: position{line: 106, col: 10, offset: 1822},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 106, col: 10, offset: 1822},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 106, col: 12, offset: 1824},
							val:        "\"",
							ignoreCase: false,
							want:       "\"\\\"\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 106, col: 16, offset: 1828},
							expr: &charClassMatcher{
								pos:        position{line: 106, col: 16, offset: 1828},
								val:        "[^\"]",
								chars:      []rune{'"'},
								ignoreCase: false,
								inverted:   true,
							},
						},
						&litMatcher{
							pos:        position{line: 106, col: 22, offset: 1834},
							val:        "\"",
							ignoreCase: false,
							want:       "\"\\\"\"",
						},
						&ruleRefExpr{
							pos:  position{line: 106, col: 26, offset: 1838},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "NUMBER",
			pos:  position{line: 111, col: 1, offset: 1911},
			expr: &actionExpr{
				pos: position{line: 111, col: 10, offset: 1920},
				run: (*parser).callonNUMBER1,
				expr: &seqExpr{
					pos: position{line: 111, col: 10, offset: 1920},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 111, col: 10, offset: 1920},
							name: "_",
						},
						&oneOrMoreExpr{
							pos: position{line: 111, col: 12, offset: 1922},
							expr: &ruleRefExpr{
								pos:  position{line: 111, col: 12, offset: 1922},
								name: "DIGIT",
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 111, col: 19, offset: 1929},
							expr: &seqExpr{
								pos: position{line: 111, col: 20, offset: 1930},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 111, col: 20, offset: 1930},
										val:        ".",
										ignoreCase: false,
										want:       "\".\"",
									},
									&oneOrMoreExpr{
										pos: position{line: 111, col: 24, offset: 1934},
										expr: &ruleRefExpr{
											pos:  position{line: 111, col: 24, offset: 1934},
											name: "DIGIT",
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 111, col: 33, offset: 1943},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "LEFT_PAREN",
			pos:  position{line: 120, col: 1, offset: 2095},
			expr: &actionExpr{
				pos: position{line: 120, col: 17, offset: 2111},
				run: (*parser).callonLEFT_PAREN1,
				expr: &seqExpr{
					pos: position{line: 120, col: 17, offset: 2111},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 120, col: 17, offset: 2111},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 120, col: 19, offset: 2113},
							val:        "(",
							ignoreCase: false,
							want:       "\"(\"",
						},
						&ruleRefExpr{
							pos:  position{line: 120, col: 23, offset: 2117},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "RIGHT_PAREN",
			pos:  position{line: 121, col: 1, offset: 2155},
			expr: &actionExpr{
				pos: position{line: 121, col: 17, offset: 2171},
				run: (*parser).callonRIGHT_PAREN1,
				expr: &seqExpr{
					pos: position{line: 121, col: 17, offset: 2171},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 121, col: 17, offset: 2171},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 121, col: 19, offset: 2173},
							val:        ")",
							ignoreCase: false,
							want:       "\")\"",
						},
						&ruleRefExpr{
							pos:  position{line: 121, col: 23, offset: 2177},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "LEFT_BRACE",
			pos:  position{line: 122, col: 1, offset: 2216},
			expr: &actionExpr{
				pos: position{line: 122, col: 17, offset: 2232},
				run: (*parser).callonLEFT_BRACE1,
				expr: &seqExpr{
					pos: position{line: 122, col: 17, offset: 2232},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 122, col: 17, offset: 2232},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 122, col: 19, offset: 2234},
							val:        "{",
							ignoreCase: false,
							want:       "\"{\"",
						},
						&ruleRefExpr{
							pos:  position{line: 122, col: 23, offset: 2238},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "RIGHT_BRACE",
			pos:  position{line: 123, col: 1, offset: 2270},
			expr: &actionExpr{
				pos: position{line: 123, col: 17, offset: 2286},
				run: (*parser).callonRIGHT_BRACE1,
				expr: &seqExpr{
					pos: position{line: 123, col: 17, offset: 2286},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 123, col: 17, offset: 2286},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 123, col: 19, offset: 2288},
							val:        "}",
							ignoreCase: false,
							want:       "\"}\"",
						},
						&ruleRefExpr{
							pos:  position{line: 123, col: 23, offset: 2292},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "COMMA",
			pos:  position{line: 124, col: 1, offset: 2325},
			expr: &actionExpr{
				pos: position{line: 124, col: 17, offset: 2341},
				run: (*parser).callonCOMMA1,
				expr: &seqExpr{
					pos: position{line: 124, col: 17, offset: 2341},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 124, col: 17, offset: 2341},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 124, col: 19, offset: 2343},
							val:        ",",
							ignoreCase: false,
							want:       "\",\"",
						},
						&ruleRefExpr{
							pos:  position{line: 124, col: 23, offset: 2347},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "DOT",
			pos:  position{line: 125, col: 1, offset: 2375},
			expr: &actionExpr{
				pos: position{line: 125, col: 17, offset: 2391},
				run: (*parser).callonDOT1,
				expr: &seqExpr{
					pos: position{line: 125, col: 17, offset: 2391},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 125, col: 17, offset: 2391},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 125, col: 19, offset: 2393},
							val:        ".",
							ignoreCase: false,
							want:       "\".\"",
						},
						&ruleRefExpr{
							pos:  position{line: 125, col: 23, offset: 2397},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "MINUS",
			pos:  position{line: 126, col: 1, offset: 2423},
			expr: &actionExpr{
				pos: position{line: 126, col: 17, offset: 2439},
				run: (*parser).callonMINUS1,
				expr: &seqExpr{
					pos: position{line: 126, col: 17, offset: 2439},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 126, col: 17, offset: 2439},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 126, col: 19, offset: 2441},
							val:        "-",
							ignoreCase: false,
							want:       "\"-\"",
						},
						&ruleRefExpr{
							pos:  position{line: 126, col: 23, offset: 2445},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "PLUS",
			pos:  position{line: 127, col: 1, offset: 2473},
			expr: &actionExpr{
				pos: position{line: 127, col: 17, offset: 2489},
				run: (*parser).callonPLUS1,
				expr: &seqExpr{
					pos: position{line: 127, col: 17, offset: 2489},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 127, col: 17, offset: 2489},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 127, col: 19, offset: 2491},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&ruleRefExpr{
							pos:  position{line: 127, col: 23, offset: 2495},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "SEMICOLON",
			pos:  position{line: 128, col: 1, offset: 2522},
			expr: &actionExpr{
				pos: position{line: 128, col: 17, offset: 2538},
				run: (*parser).callonSEMICOLON1,
				expr: &seqExpr{
					pos: position{line: 128, col: 17, offset: 2538},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 128, col: 17, offset: 2538},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 128, col: 19, offset: 2540},
							val:        ";",
							ignoreCase: false,
							want:       "\";\"",
						},
						&ruleRefExpr{
							pos:  position{line: 128, col: 23, offset: 2544},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "SLASH",
			pos:  position{line: 129, col: 1, offset: 2576},
			expr: &actionExpr{
				pos: position{line: 129, col: 17, offset: 2592},
				run: (*parser).callonSLASH1,
				expr: &seqExpr{
					pos: position{line: 129, col: 17, offset: 2592},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 129, col: 17, offset: 2592},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 129, col: 19, offset: 2594},
							val:        "/",
							ignoreCase: false,
							want:       "\"/\"",
						},
						&ruleRefExpr{
							pos:  position{line: 129, col: 23, offset: 2598},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "STAR",
			pos:  position{line: 130, col: 1, offset: 2626},
			expr: &actionExpr{
				pos: position{line: 130, col: 17, offset: 2642},
				run: (*parser).callonSTAR1,
				expr: &seqExpr{
					pos: position{line: 130, col: 17, offset: 2642},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 130, col: 17, offset: 2642},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 130, col: 19, offset: 2644},
							val:        "*",
							ignoreCase: false,
							want:       "\"*\"",
						},
						&ruleRefExpr{
							pos:  position{line: 130, col: 23, offset: 2648},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "BANG",
			pos:  position{line: 131, col: 1, offset: 2675},
			expr: &actionExpr{
				pos: position{line: 131, col: 17, offset: 2691},
				run: (*parser).callonBANG1,
				expr: &seqExpr{
					pos: position{line: 131, col: 17, offset: 2691},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 131, col: 17, offset: 2691},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 131, col: 19, offset: 2693},
							val:        "!",
							ignoreCase: false,
							want:       "\"!\"",
						},
						&ruleRefExpr{
							pos:  position{line: 131, col: 23, offset: 2697},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "EQUAL",
			pos:  position{line: 132, col: 1, offset: 2724},
			expr: &actionExpr{
				pos: position{line: 132, col: 17, offset: 2740},
				run: (*parser).callonEQUAL1,
				expr: &seqExpr{
					pos: position{line: 132, col: 17, offset: 2740},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 132, col: 17, offset: 2740},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 132, col: 19, offset: 2742},
							val:        "=",
							ignoreCase: false,
							want:       "\"=\"",
						},
						&ruleRefExpr{
							pos:  position{line: 132, col: 23, offset: 2746},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "GREATER",
			pos:  position{line: 133, col: 1, offset: 2774},
			expr: &actionExpr{
				pos: position{line: 133, col: 17, offset: 2790},
				run: (*parser).callonGREATER1,
				expr: &seqExpr{
					pos: position{line: 133, col: 17, offset: 2790},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 133, col: 17, offset: 2790},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 133, col: 19, offset: 2792},
							val:        ">",
							ignoreCase: false,
							want:       "\">\"",
						},
						&ruleRefExpr{
							pos:  position{line: 133, col: 23, offset: 2796},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "LESS",
			pos:  position{line: 134, col: 1, offset: 2826},
			expr: &actionExpr{
				pos: position{line: 134, col: 17, offset: 2842},
				run: (*parser).callonLESS1,
				expr: &seqExpr{
					pos: position{line: 134, col: 17, offset: 2842},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 134, col: 17, offset: 2842},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 134, col: 19, offset: 2844},
							val:        "<",
							ignoreCase: false,
							want:       "\"<\"",
						},
						&ruleRefExpr{
							pos:  position{line: 134, col: 23, offset: 2848},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "BANG_EQUAL",
			pos:  position{line: 136, col: 1, offset: 2877},
			expr: &actionExpr{
				pos: position{line: 136, col: 17, offset: 2893},
				run: (*parser).callonBANG_EQUAL1,
				expr: &seqExpr{
					pos: position{line: 136, col: 17, offset: 2893},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 136, col: 17, offset: 2893},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 136, col: 19, offset: 2895},
							val:        "!=",
							ignoreCase: false,
							want:       "\"!=\"",
						},
						&ruleRefExpr{
							pos:  position{line: 136, col: 24, offset: 2900},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "EQUAL_EQUAL",
			pos:  position{line: 137, col: 1, offset: 2932},
			expr: &actionExpr{
				pos: position{line: 137, col: 17, offset: 2948},
				run: (*parser).callonEQUAL_EQUAL1,
				expr: &seqExpr{
					pos: position{line: 137, col: 17, offset: 2948},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 137, col: 17, offset: 2948},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 137, col: 19, offset: 2950},
							val:        "==",
							ignoreCase: false,
							want:       "\"==\"",
						},
						&ruleRefExpr{
							pos:  position{line: 137, col: 24, offset: 2955},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "GREATER_EQUAL",
			pos:  position{line: 138, col: 1, offset: 2988},
			expr: &actionExpr{
				pos: position{line: 138, col: 17, offset: 3004},
				run: (*parser).callonGREATER_EQUAL1,
				expr: &seqExpr{
					pos: position{line: 138, col: 17, offset: 3004},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 138, col: 17, offset: 3004},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 138, col: 19, offset: 3006},
							val:        ">=",
							ignoreCase: false,
							want:       "\">=\"",
						},
						&ruleRefExpr{
							pos:  position{line: 138, col: 24, offset: 3011},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "LESS_EQUAL",
			pos:  position{line: 139, col: 1, offset: 3046},
			expr: &actionExpr{
				pos: position{line: 139, col: 17, offset: 3062},
				run: (*parser).callonLESS_EQUAL1,
				expr: &seqExpr{
					pos: position{line: 139, col: 17, offset: 3062},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 139, col: 17, offset: 3062},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 139, col: 19, offset: 3064},
							val:        "<=",
							ignoreCase: false,
							want:       "\"<=\"",
						},
						&ruleRefExpr{
							pos:  position{line: 139, col: 24, offset: 3069},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "AND",
			pos:  position{line: 141, col: 1, offset: 3103},
			expr: &actionExpr{
				pos: position{line: 141, col: 17, offset: 3119},
				run: (*parser).callonAND1,
				expr: &seqExpr{
					pos: position{line: 141, col: 17, offset: 3119},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 141, col: 17, offset: 3119},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 141, col: 19, offset: 3121},
							val:        "and",
							ignoreCase: false,
							want:       "\"and\"",
						},
						&ruleRefExpr{
							pos:  position{line: 141, col: 28, offset: 3130},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "CLASS",
			pos:  position{line: 142, col: 1, offset: 3156},
			expr: &actionExpr{
				pos: position{line: 142, col: 17, offset: 3172},
				run: (*parser).callonCLASS1,
				expr: &seqExpr{
					pos: position{line: 142, col: 17, offset: 3172},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 142, col: 17, offset: 3172},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 142, col: 19, offset: 3174},
							val:        "class",
							ignoreCase: false,
							want:       "\"class\"",
						},
						&ruleRefExpr{
							pos:  position{line: 142, col: 28, offset: 3183},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "ELSE",
			pos:  position{line: 143, col: 1, offset: 3211},
			expr: &actionExpr{
				pos: position{line: 143, col: 17, offset: 3227},
				run: (*parser).callonELSE1,
				expr: &seqExpr{
					pos: position{line: 143, col: 17, offset: 3227},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 143, col: 17, offset: 3227},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 143, col: 19, offset: 3229},
							val:        "else",
							ignoreCase: false,
							want:       "\"else\"",
						},
						&ruleRefExpr{
							pos:  position{line: 143, col: 28, offset: 3238},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "FALSE",
			pos:  position{line: 144, col: 1, offset: 3265},
			expr: &actionExpr{
				pos: position{line: 144, col: 17, offset: 3281},
				run: (*parser).callonFALSE1,
				expr: &seqExpr{
					pos: position{line: 144, col: 17, offset: 3281},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 144, col: 17, offset: 3281},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 144, col: 19, offset: 3283},
							val:        "false",
							ignoreCase: false,
							want:       "\"false\"",
						},
						&ruleRefExpr{
							pos:  position{line: 144, col: 28, offset: 3292},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "FOR",
			pos:  position{line: 145, col: 1, offset: 3320},
			expr: &actionExpr{
				pos: position{line: 145, col: 17, offset: 3336},
				run: (*parser).callonFOR1,
				expr: &seqExpr{
					pos: position{line: 145, col: 17, offset: 3336},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 145, col: 17, offset: 3336},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 145, col: 19, offset: 3338},
							val:        "for",
							ignoreCase: false,
							want:       "\"for\"",
						},
						&ruleRefExpr{
							pos:  position{line: 145, col: 28, offset: 3347},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "FUN",
			pos:  position{line: 146, col: 1, offset: 3373},
			expr: &actionExpr{
				pos: position{line: 146, col: 17, offset: 3389},
				run: (*parser).callonFUN1,
				expr: &seqExpr{
					pos: position{line: 146, col: 17, offset: 3389},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 146, col: 17, offset: 3389},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 146, col: 19, offset: 3391},
							val:        "fun",
							ignoreCase: false,
							want:       "\"fun\"",
						},
						&ruleRefExpr{
							pos:  position{line: 146, col: 28, offset: 3400},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "IF",
			pos:  position{line: 147, col: 1, offset: 3426},
			expr: &actionExpr{
				pos: position{line: 147, col: 17, offset: 3442},
				run: (*parser).callonIF1,
				expr: &seqExpr{
					pos: position{line: 147, col: 17, offset: 3442},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 147, col: 17, offset: 3442},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 147, col: 19, offset: 3444},
							val:        "if",
							ignoreCase: false,
							want:       "\"if\"",
						},
						&ruleRefExpr{
							pos:  position{line: 147, col: 28, offset: 3453},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "NIL",
			pos:  position{line: 148, col: 1, offset: 3478},
			expr: &actionExpr{
				pos: position{line: 148, col: 17, offset: 3494},
				run: (*parser).callonNIL1,
				expr: &seqExpr{
					pos: position{line: 148, col: 17, offset: 3494},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 148, col: 17, offset: 3494},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 148, col: 19, offset: 3496},
							val:        "nil",
							ignoreCase: false,
							want:       "\"nil\"",
						},
						&ruleRefExpr{
							pos:  position{line: 148, col: 28, offset: 3505},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "OR",
			pos:  position{line: 149, col: 1, offset: 3531},
			expr: &actionExpr{
				pos: position{line: 149, col: 17, offset: 3547},
				run: (*parser).callonOR1,
				expr: &seqExpr{
					pos: position{line: 149, col: 17, offset: 3547},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 149, col: 17, offset: 3547},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 149, col: 19, offset: 3549},
							val:        "or",
							ignoreCase: false,
							want:       "\"or\"",
						},
						&ruleRefExpr{
							pos:  position{line: 149, col: 28, offset: 3558},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "PRINT",
			pos:  position{line: 150, col: 1, offset: 3583},
			expr: &actionExpr{
				pos: position{line: 150, col: 17, offset: 3599},
				run: (*parser).callonPRINT1,
				expr: &seqExpr{
					pos: position{line: 150, col: 17, offset: 3599},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 150, col: 17, offset: 3599},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 150, col: 19, offset: 3601},
							val:        "print",
							ignoreCase: false,
							want:       "\"print\"",
						},
						&ruleRefExpr{
							pos:  position{line: 150, col: 28, offset: 3610},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "RETURN",
			pos:  position{line: 151, col: 1, offset: 3638},
			expr: &actionExpr{
				pos: position{line: 151, col: 17, offset: 3654},
				run: (*parser).callonRETURN1,
				expr: &seqExpr{
					pos: position{line: 151, col: 17, offset: 3654},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 151, col: 17, offset: 3654},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 151, col: 19, offset: 3656},
							val:        "return",
							ignoreCase: false,
							want:       "\"return\"",
						},
						&ruleRefExpr{
							pos:  position{line: 151, col: 28, offset: 3665},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "SUPER",
			pos:  position{line: 152, col: 1, offset: 3694},
			expr: &actionExpr{
				pos: position{line: 152, col: 17, offset: 3710},
				run: (*parser).callonSUPER1,
				expr: &seqExpr{
					pos: position{line: 152, col: 17, offset: 3710},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 152, col: 17, offset: 3710},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 152, col: 19, offset: 3712},
							val:        "super",
							ignoreCase: false,
							want:       "\"super\"",
						},
						&ruleRefExpr{
							pos:  position{line: 152, col: 28, offset: 3721},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "THIS",
			pos:  position{line: 153, col: 1, offset: 3749},
			expr: &actionExpr{
				pos: position{line: 153, col: 17, offset: 3765},
				run: (*parser).callonTHIS1,
				expr: &seqExpr{
					pos: position{line: 153, col: 17, offset: 3765},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 153, col: 17, offset: 3765},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 153, col: 19, offset: 3767},
							val:        "this",
							ignoreCase: false,
							want:       "\"this\"",
						},
						&ruleRefExpr{
							pos:  position{line: 153, col: 28, offset: 3776},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "TRUE",
			pos:  position{line: 154, col: 1, offset: 3803},
			expr: &actionExpr{
				pos: position{line: 154, col: 17, offset: 3819},
				run: (*parser).callonTRUE1,
				expr: &seqExpr{
					pos: position{line: 154, col: 17, offset: 3819},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 154, col: 17, offset: 3819},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 154, col: 19, offset: 3821},
							val:        "true",
							ignoreCase: false,
							want:       "\"true\"",
						},
						&ruleRefExpr{
							pos:  position{line: 154, col: 28, offset: 3830},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "VAR",
			pos:  position{line: 155, col: 1, offset: 3857},
			expr: &actionExpr{
				pos: position{line: 155, col: 17, offset: 3873},
				run: (*parser).callonVAR1,
				expr: &seqExpr{
					pos: position{line: 155, col: 17, offset: 3873},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 155, col: 17, offset: 3873},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 155, col: 19, offset: 3875},
							val:        "var",
							ignoreCase: false,
							want:       "\"var\"",
						},
						&ruleRefExpr{
							pos:  position{line: 155, col: 28, offset: 3884},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "WHILE",
			pos:  position{line: 156, col: 1, offset: 3910},
			expr: &actionExpr{
				pos: position{line: 156, col: 17, offset: 3926},
				run: (*parser).callonWHILE1,
				expr: &seqExpr{
					pos: position{line: 156, col: 17, offset: 3926},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 156, col: 17, offset: 3926},
							name: "_",
						},
						&litMatcher{
							pos:        position{line: 156, col: 19, offset: 3928},
							val:        "while",
							ignoreCase: false,
							want:       "\"while\"",
						},
						&ruleRefExpr{
							pos:  position{line: 156, col: 28, offset: 3937},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "arguments",
			pos:  position{line: 161, col: 1, offset: 4000},
			expr: &actionExpr{
				pos: position{line: 161, col: 13, offset: 4012},
				run: (*parser).callonarguments1,
				expr: &labeledExpr{
					pos:   position{line: 161, col: 13, offset: 4012},
					label: "args",
					expr: &seqExpr{
						pos: position{line: 161, col: 19, offset: 4018},
						exprs: []any{
							&ruleRefExpr{
								pos:  position{line: 161, col: 19, offset: 4018},
								name: "Expression",
							},
							&zeroOrMoreExpr{
								pos: position{line: 161, col: 30, offset: 4029},
								expr: &seqExpr{
									pos: position{line: 161, col: 31, offset: 4030},
									exprs: []any{
										&ruleRefExpr{
											pos:  position{line: 161, col: 31, offset: 4030},
											name: "COMMA",
										},
										&ruleRefExpr{
											pos:  position{line: 161, col: 37, offset: 4036},
											name: "Expression",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "parameters",
			pos:  position{line: 165, col: 1, offset: 4106},
			expr: &actionExpr{
				pos: position{line: 165, col: 14, offset: 4119},
				run: (*parser).callonparameters1,
				expr: &labeledExpr{
					pos:   position{line: 165, col: 14, offset: 4119},
					label: "params",
					expr: &seqExpr{
						pos: position{line: 165, col: 22, offset: 4127},
						exprs: []any{
							&ruleRefExpr{
								pos:  position{line: 165, col: 22, offset: 4127},
								name: "IDENTIFIER",
							},
							&zeroOrMoreExpr{
								pos: position{line: 165, col: 33, offset: 4138},
								expr: &seqExpr{
									pos: position{line: 165, col: 34, offset: 4139},
									exprs: []any{
										&ruleRefExpr{
											pos:  position{line: 165, col: 34, offset: 4139},
											name: "COMMA",
										},
										&ruleRefExpr{
											pos:  position{line: 165, col: 40, offset: 4145},
											name: "IDENTIFIER",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "function",
			pos:  position{line: 169, col: 1, offset: 4217},
			expr: &actionExpr{
				pos: position{line: 169, col: 12, offset: 4228},
				run: (*parser).callonfunction1,
				expr: &seqExpr{
					pos: position{line: 169, col: 12, offset: 4228},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 169, col: 12, offset: 4228},
							label: "name",
							expr: &ruleRefExpr{
								pos:  position{line: 169, col: 17, offset: 4233},
								name: "IDENTIFIER",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 169, col: 28, offset: 4244},
							name: "LEFT_PAREN",
						},
						&labeledExpr{
							pos:   position{line: 169, col: 39, offset: 4255},
							label: "params",
							expr: &zeroOrOneExpr{
								pos: position{line: 169, col: 46, offset: 4262},
								expr: &ruleRefExpr{
									pos:  position{line: 169, col: 46, offset: 4262},
									name: "parameters",
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 169, col: 58, offset: 4274},
							name: "RIGHT_PAREN",
						},
						&labeledExpr{
							pos:   position{line: 169, col: 70, offset: 4286},
							label: "body",
							expr: &ruleRefExpr{
								pos:  position{line: 169, col: 75, offset: 4291},
								name: "Block",
							},
						},
					},
				},
			},
		},
		{
			name: "Primary",
			pos:  position{line: 179, col: 1, offset: 4489},
			expr: &choiceExpr{
				pos: position{line: 180, col: 4, offset: 4501},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 180, col: 4, offset: 4501},
						run: (*parser).callonPrimary2,
						expr: &ruleRefExpr{
							pos:  position{line: 180, col: 4, offset: 4501},
							name: "TRUE",
						},
					},
					&actionExpr{
						pos: position{line: 181, col: 4, offset: 4559},
						run: (*parser).callonPrimary4,
						expr: &ruleRefExpr{
							pos:  position{line: 181, col: 4, offset: 4559},
							name: "FALSE",
						},
					},
					&actionExpr{
						pos: position{line: 182, col: 4, offset: 4618},
						run: (*parser).callonPrimary6,
						expr: &ruleRefExpr{
							pos:  position{line: 182, col: 4, offset: 4618},
							name: "NIL",
						},
					},
					&actionExpr{
						pos: position{line: 183, col: 4, offset: 4661},
						run: (*parser).callonPrimary8,
						expr: &ruleRefExpr{
							pos:  position{line: 183, col: 4, offset: 4661},
							name: "THIS",
						},
					},
					&actionExpr{
						pos: position{line: 184, col: 4, offset: 4705},
						run: (*parser).callonPrimary10,
						expr: &labeledExpr{
							pos:   position{line: 184, col: 4, offset: 4705},
							label: "n",
							expr: &ruleRefExpr{
								pos:  position{line: 184, col: 6, offset: 4707},
								name: "NUMBER",
							},
						},
					},
					&actionExpr{
						pos: position{line: 185, col: 4, offset: 4740},
						run: (*parser).callonPrimary13,
						expr: &labeledExpr{
							pos:   position{line: 185, col: 4, offset: 4740},
							label: "s",
							expr: &ruleRefExpr{
								pos:  position{line: 185, col: 6, offset: 4742},
								name: "STRING",
							},
						},
					},
					&actionExpr{
						pos: position{line: 186, col: 4, offset: 4775},
						run: (*parser).callonPrimary16,
						expr: &labeledExpr{
							pos:   position{line: 186, col: 4, offset: 4775},
							label: "i",
							expr: &ruleRefExpr{
								pos:  position{line: 186, col: 6, offset: 4777},
								name: "IDENTIFIER",
							},
						},
					},
					&actionExpr{
						pos: position{line: 187, col: 4, offset: 4810},
						run: (*parser).callonPrimary19,
						expr: &seqExpr{
							pos: position{line: 187, col: 4, offset: 4810},
							exprs: []any{
								&ruleRefExpr{
									pos:  position{line: 187, col: 4, offset: 4810},
									name: "LEFT_PAREN",
								},
								&labeledExpr{
									pos:   position{line: 187, col: 15, offset: 4821},
									label: "e",
									expr: &ruleRefExpr{
										pos:  position{line: 187, col: 17, offset: 4823},
										name: "Expression",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 187, col: 28, offset: 4834},
									name: "RIGHT_PAREN",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 190, col: 4, offset: 4873},
						run: (*parser).callonPrimary25,
						expr: &seqExpr{
							pos: position{line: 190, col: 4, offset: 4873},
							exprs: []any{
								&ruleRefExpr{
									pos:  position{line: 190, col: 4, offset: 4873},
									name: "SUPER",
								},
								&ruleRefExpr{
									pos:  position{line: 190, col: 10, offset: 4879},
									name: "DOT",
								},
								&labeledExpr{
									pos:   position{line: 190, col: 14, offset: 4883},
									label: "i",
									expr: &ruleRefExpr{
										pos:  position{line: 190, col: 16, offset: 4885},
										name: "IDENTIFIER",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Call",
			pos:  position{line: 197, col: 1, offset: 5017},
			expr: &actionExpr{
				pos: position{line: 197, col: 8, offset: 5024},
				run: (*parser).callonCall1,
				expr: &seqExpr{
					pos: position{line: 197, col: 8, offset: 5024},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 197, col: 8, offset: 5024},
							label: "e",
							expr: &ruleRefExpr{
								pos:  position{line: 197, col: 10, offset: 5026},
								name: "Primary",
							},
						},
						&labeledExpr{
							pos:   position{line: 197, col: 18, offset: 5034},
							label: "pat",
							expr: &zeroOrMoreExpr{
								pos: position{line: 197, col: 22, offset: 5038},
								expr: &choiceExpr{
									pos: position{line: 197, col: 23, offset: 5039},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 197, col: 23, offset: 5039},
											exprs: []any{
												&ruleRefExpr{
													pos:  position{line: 197, col: 23, offset: 5039},
													name: "LEFT_PAREN",
												},
												&zeroOrOneExpr{
													pos: position{line: 197, col: 34, offset: 5050},
													expr: &ruleRefExpr{
														pos:  position{line: 197, col: 34, offset: 5050},
														name: "arguments",
													},
												},
												&ruleRefExpr{
													pos:  position{line: 197, col: 45, offset: 5061},
													name: "RIGHT_PAREN",
												},
											},
										},
										&seqExpr{
											pos: position{line: 197, col: 59, offset: 5075},
											exprs: []any{
												&ruleRefExpr{
													pos:  position{line: 197, col: 59, offset: 5075},
													name: "DOT",
												},
												&ruleRefExpr{
													pos:  position{line: 197, col: 63, offset: 5079},
													name: "IDENTIFIER",
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Unary",
			pos:  position{line: 219, col: 1, offset: 5586},
			expr: &choiceExpr{
				pos: position{line: 219, col: 9, offset: 5594},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 219, col: 9, offset: 5594},
						run: (*parser).callonUnary2,
						expr: &seqExpr{
							pos: position{line: 219, col: 9, offset: 5594},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 219, col: 9, offset: 5594},
									label: "op",
									expr: &choiceExpr{
										pos: position{line: 219, col: 13, offset: 5598},
										alternatives: []any{
											&ruleRefExpr{
												pos:  position{line: 219, col: 13, offset: 5598},
												name: "BANG",
											},
											&ruleRefExpr{
												pos:  position{line: 219, col: 20, offset: 5605},
												name: "MINUS",
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 219, col: 27, offset: 5612},
									label: "u",
									expr: &ruleRefExpr{
										pos:  position{line: 219, col: 29, offset: 5614},
										name: "Unary",
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 233, col: 5, offset: 5942},
						name: "Call",
					},
				},
			},
		},
		{
			name: "Factor",
			pos:  position{line: 235, col: 1, offset: 5950},
			expr: &actionExpr{
				pos: position{line: 235, col: 10, offset: 5959},
				run: (*parser).callonFactor1,
				expr: &seqExpr{
					pos: position{line: 235, col: 10, offset: 5959},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 235, col: 10, offset: 5959},
							label: "l",
							expr: &ruleRefExpr{
								pos:  position{line: 235, col: 12, offset: 5961},
								name: "Unary",
							},
						},
						&labeledExpr{
							pos:   position{line: 235, col: 18, offset: 5967},
							label: "pat",
							expr: &zeroOrMoreExpr{
								pos: position{line: 235, col: 22, offset: 5971},
								expr: &seqExpr{
									pos: position{line: 235, col: 23, offset: 5972},
									exprs: []any{
										&choiceExpr{
											pos: position{line: 235, col: 24, offset: 5973},
											alternatives: []any{
												&ruleRefExpr{
													pos:  position{line: 235, col: 24, offset: 5973},
													name: "SLASH",
												},
												&ruleRefExpr{
													pos:  position{line: 235, col: 32, offset: 5981},
													name: "STAR",
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 235, col: 38, offset: 5987},
											name: "Unary",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Term",
			pos:  position{line: 259, col: 1, offset: 6542},
			expr: &actionExpr{
				pos: position{line: 259, col: 8, offset: 6549},
				run: (*parser).callonTerm1,
				expr: &seqExpr{
					pos: position{line: 259, col: 8, offset: 6549},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 259, col: 8, offset: 6549},
							label: "l",
							expr: &ruleRefExpr{
								pos:  position{line: 259, col: 10, offset: 6551},
								name: "Factor",
							},
						},
						&labeledExpr{
							pos:   position{line: 259, col: 17, offset: 6558},
							label: "pat",
							expr: &zeroOrMoreExpr{
								pos: position{line: 259, col: 21, offset: 6562},
								expr: &seqExpr{
									pos: position{line: 259, col: 22, offset: 6563},
									exprs: []any{
										&choiceExpr{
											pos: position{line: 259, col: 23, offset: 6564},
											alternatives: []any{
												&ruleRefExpr{
													pos:  position{line: 259, col: 23, offset: 6564},
													name: "MINUS",
												},
												&ruleRefExpr{
													pos:  position{line: 259, col: 31, offset: 6572},
													name: "PLUS",
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 259, col: 37, offset: 6578},
											name: "Factor",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Comparison",
			pos:  position{line: 283, col: 1, offset: 7129},
			expr: &actionExpr{
				pos: position{line: 283, col: 14, offset: 7142},
				run: (*parser).callonComparison1,
				expr: &seqExpr{
					pos: position{line: 283, col: 14, offset: 7142},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 283, col: 14, offset: 7142},
							label: "l",
							expr: &ruleRefExpr{
								pos:  position{line: 283, col: 16, offset: 7144},
								name: "Term",
							},
						},
						&labeledExpr{
							pos:   position{line: 283, col: 21, offset: 7149},
							label: "pat",
							expr: &zeroOrMoreExpr{
								pos: position{line: 283, col: 25, offset: 7153},
								expr: &seqExpr{
									pos: position{line: 283, col: 26, offset: 7154},
									exprs: []any{
										&choiceExpr{
											pos: position{line: 283, col: 27, offset: 7155},
											alternatives: []any{
												&ruleRefExpr{
													pos:  position{line: 283, col: 27, offset: 7155},
													name: "GREATER_EQUAL",
												},
												&ruleRefExpr{
													pos:  position{line: 283, col: 43, offset: 7171},
													name: "LESS_EQUAL",
												},
												&ruleRefExpr{
													pos:  position{line: 283, col: 56, offset: 7184},
													name: "GREATER",
												},
												&ruleRefExpr{
													pos:  position{line: 283, col: 66, offset: 7194},
													name: "LESS",
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 283, col: 72, offset: 7200},
											name: "Term",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Equality",
			pos:  position{line: 311, col: 1, offset: 7879},
			expr: &actionExpr{
				pos: position{line: 311, col: 12, offset: 7890},
				run: (*parser).callonEquality1,
				expr: &seqExpr{
					pos: position{line: 311, col: 12, offset: 7890},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 311, col: 12, offset: 7890},
							label: "l",
							expr: &ruleRefExpr{
								pos:  position{line: 311, col: 14, offset: 7892},
								name: "Comparison",
							},
						},
						&labeledExpr{
							pos:   position{line: 311, col: 25, offset: 7903},
							label: "pat",
							expr: &zeroOrMoreExpr{
								pos: position{line: 311, col: 29, offset: 7907},
								expr: &seqExpr{
									pos: position{line: 311, col: 30, offset: 7908},
									exprs: []any{
										&choiceExpr{
											pos: position{line: 311, col: 31, offset: 7909},
											alternatives: []any{
												&ruleRefExpr{
													pos:  position{line: 311, col: 31, offset: 7909},
													name: "BANG_EQUAL",
												},
												&ruleRefExpr{
													pos:  position{line: 311, col: 44, offset: 7922},
													name: "EQUAL_EQUAL",
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 311, col: 57, offset: 7935},
											name: "Comparison",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "LogicalAnd",
			pos:  position{line: 335, col: 1, offset: 8506},
			expr: &actionExpr{
				pos: position{line: 335, col: 14, offset: 8519},
				run: (*parser).callonLogicalAnd1,
				expr: &seqExpr{
					pos: position{line: 335, col: 14, offset: 8519},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 335, col: 14, offset: 8519},
							label: "l",
							expr: &ruleRefExpr{
								pos:  position{line: 335, col: 16, offset: 8521},
								name: "Equality",
							},
						},
						&labeledExpr{
							pos:   position{line: 335, col: 25, offset: 8530},
							label: "pat",
							expr: &zeroOrMoreExpr{
								pos: position{line: 335, col: 29, offset: 8534},
								expr: &seqExpr{
									pos: position{line: 335, col: 30, offset: 8535},
									exprs: []any{
										&ruleRefExpr{
											pos:  position{line: 335, col: 30, offset: 8535},
											name: "AND",
										},
										&ruleRefExpr{
											pos:  position{line: 335, col: 34, offset: 8539},
											name: "Equality",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "LogicalOr",
			pos:  position{line: 350, col: 1, offset: 8859},
			expr: &actionExpr{
				pos: position{line: 350, col: 13, offset: 8871},
				run: (*parser).callonLogicalOr1,
				expr: &seqExpr{
					pos: position{line: 350, col: 13, offset: 8871},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 350, col: 13, offset: 8871},
							label: "l",
							expr: &ruleRefExpr{
								pos:  position{line: 350, col: 15, offset: 8873},
								name: "LogicalAnd",
							},
						},
						&labeledExpr{
							pos:   position{line: 350, col: 26, offset: 8884},
							label: "pat",
							expr: &zeroOrMoreExpr{
								pos: position{line: 350, col: 30, offset: 8888},
								expr: &seqExpr{
									pos: position{line: 350, col: 31, offset: 8889},
									exprs: []any{
										&ruleRefExpr{
											pos:  position{line: 350, col: 31, offset: 8889},
											name: "OR",
										},
										&ruleRefExpr{
											pos:  position{line: 350, col: 34, offset: 8892},
											name: "LogicalAnd",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Assignment",
			pos:  position{line: 365, col: 1, offset: 9213},
			expr: &choiceExpr{
				pos: position{line: 365, col: 14, offset: 9226},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 365, col: 14, offset: 9226},
						run: (*parser).callonAssignment2,
						expr: &seqExpr{
							pos: position{line: 365, col: 14, offset: 9226},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 365, col: 14, offset: 9226},
									label: "prev",
									expr: &zeroOrOneExpr{
										pos: position{line: 365, col: 19, offset: 9231},
										expr: &seqExpr{
											pos: position{line: 365, col: 20, offset: 9232},
											exprs: []any{
												&ruleRefExpr{
													pos:  position{line: 365, col: 20, offset: 9232},
													name: "Call",
												},
												&ruleRefExpr{
													pos:  position{line: 365, col: 25, offset: 9237},
													name: "DOT",
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 365, col: 31, offset: 9243},
									label: "i",
									expr: &ruleRefExpr{
										pos:  position{line: 365, col: 33, offset: 9245},
										name: "IDENTIFIER",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 365, col: 44, offset: 9256},
									name: "EQUAL",
								},
								&labeledExpr{
									pos:   position{line: 365, col: 50, offset: 9262},
									label: "e",
									expr: &ruleRefExpr{
										pos:  position{line: 365, col: 52, offset: 9264},
										name: "Assignment",
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 380, col: 5, offset: 9617},
						name: "LogicalOr",
					},
				},
			},
		},
		{
			name: "Expression",
			pos:  position{line: 382, col: 1, offset: 9630},
			expr: &ruleRefExpr{
				pos:  position{line: 382, col: 14, offset: 9643},
				name: "Assignment",
			},
		},
	},
}

func (c *current) onIDENTIFIER1() (any, error) {

	str := matchedTextOf(c)
	return ast.Identifier(str), nil
}

func (p *parser) callonIDENTIFIER1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIDENTIFIER1()
}

func (c *current) onSTRING1() (any, error) {

	str := matchedTextOf(c)
	return ast.StringLiteral(str), nil
}

func (p *parser) callonSTRING1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSTRING1()
}

func (c *current) onNUMBER1() (any, error) {

	str := matchedTextOf(c)
	n, err := strconv.ParseFloat(str, 64)
	if err != nil {
		return nil, err
	}
	return ast.NumberLiteral(n), nil
}

func (p *parser) callonNUMBER1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onNUMBER1()
}

func (c *current) onLEFT_PAREN1() (any, error) {
	return TokLeftParenthesis, nil
}

func (p *parser) callonLEFT_PAREN1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLEFT_PAREN1()
}

func (c *current) onRIGHT_PAREN1() (any, error) {
	return TokRightParenthesis, nil
}

func (p *parser) callonRIGHT_PAREN1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRIGHT_PAREN1()
}

func (c *current) onLEFT_BRACE1() (any, error) {
	return TokLeftBrace, nil
}

func (p *parser) callonLEFT_BRACE1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLEFT_BRACE1()
}

func (c *current) onRIGHT_BRACE1() (any, error) {
	return TokRightBrace, nil
}

func (p *parser) callonRIGHT_BRACE1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRIGHT_BRACE1()
}

func (c *current) onCOMMA1() (any, error) {
	return TokComma, nil
}

func (p *parser) callonCOMMA1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCOMMA1()
}

func (c *current) onDOT1() (any, error) {
	return TokDot, nil
}

func (p *parser) callonDOT1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDOT1()
}

func (c *current) onMINUS1() (any, error) {
	return TokMinus, nil
}

func (p *parser) callonMINUS1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMINUS1()
}

func (c *current) onPLUS1() (any, error) {
	return TokPlus, nil
}

func (p *parser) callonPLUS1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPLUS1()
}

func (c *current) onSEMICOLON1() (any, error) {
	return TokSemicolon, nil
}

func (p *parser) callonSEMICOLON1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSEMICOLON1()
}

func (c *current) onSLASH1() (any, error) {
	return TokSlash, nil
}

func (p *parser) callonSLASH1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSLASH1()
}

func (c *current) onSTAR1() (any, error) {
	return TokStar, nil
}

func (p *parser) callonSTAR1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSTAR1()
}

func (c *current) onBANG1() (any, error) {
	return TokBang, nil
}

func (p *parser) callonBANG1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBANG1()
}

func (c *current) onEQUAL1() (any, error) {
	return TokEqual, nil
}

func (p *parser) callonEQUAL1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEQUAL1()
}

func (c *current) onGREATER1() (any, error) {
	return TokGreater, nil
}

func (p *parser) callonGREATER1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGREATER1()
}

func (c *current) onLESS1() (any, error) {
	return TokLess, nil
}

func (p *parser) callonLESS1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLESS1()
}

func (c *current) onBANG_EQUAL1() (any, error) {
	return TokBangEqual, nil
}

func (p *parser) callonBANG_EQUAL1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBANG_EQUAL1()
}

func (c *current) onEQUAL_EQUAL1() (any, error) {
	return TokEqualEqual, nil
}

func (p *parser) callonEQUAL_EQUAL1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEQUAL_EQUAL1()
}

func (c *current) onGREATER_EQUAL1() (any, error) {
	return TokGreaterEqual, nil
}

func (p *parser) callonGREATER_EQUAL1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGREATER_EQUAL1()
}

func (c *current) onLESS_EQUAL1() (any, error) {
	return TokLessEqual, nil
}

func (p *parser) callonLESS_EQUAL1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLESS_EQUAL1()
}

func (c *current) onAND1() (any, error) {
	return TokAnd, nil
}

func (p *parser) callonAND1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAND1()
}

func (c *current) onCLASS1() (any, error) {
	return TokClass, nil
}

func (p *parser) callonCLASS1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCLASS1()
}

func (c *current) onELSE1() (any, error) {
	return TokElse, nil
}

func (p *parser) callonELSE1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onELSE1()
}

func (c *current) onFALSE1() (any, error) {
	return TokFalse, nil
}

func (p *parser) callonFALSE1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFALSE1()
}

func (c *current) onFOR1() (any, error) {
	return TokFor, nil
}

func (p *parser) callonFOR1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFOR1()
}

func (c *current) onFUN1() (any, error) {
	return TokFun, nil
}

func (p *parser) callonFUN1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFUN1()
}

func (c *current) onIF1() (any, error) {
	return TokIf, nil
}

func (p *parser) callonIF1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIF1()
}

func (c *current) onNIL1() (any, error) {
	return TokNil, nil
}

func (p *parser) callonNIL1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onNIL1()
}

func (c *current) onOR1() (any, error) {
	return TokOr, nil
}

func (p *parser) callonOR1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOR1()
}

func (c *current) onPRINT1() (any, error) {
	return TokPrint, nil
}

func (p *parser) callonPRINT1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPRINT1()
}

func (c *current) onRETURN1() (any, error) {
	return TokReturn, nil
}

func (p *parser) callonRETURN1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRETURN1()
}

func (c *current) onSUPER1() (any, error) {
	return TokSuper, nil
}

func (p *parser) callonSUPER1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSUPER1()
}

func (c *current) onTHIS1() (any, error) {
	return TokThis, nil
}

func (p *parser) callonTHIS1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTHIS1()
}

func (c *current) onTRUE1() (any, error) {
	return TokTrue, nil
}

func (p *parser) callonTRUE1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTRUE1()
}

func (c *current) onVAR1() (any, error) {
	return TokVar, nil
}

func (p *parser) callonVAR1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onVAR1()
}

func (c *current) onWHILE1() (any, error) {
	return TokWhile, nil
}

func (p *parser) callonWHILE1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onWHILE1()
}

func (c *current) onarguments1(args any) (any, error) {

	return recursiveResolveExpressions(args), nil
}

func (p *parser) callonarguments1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onarguments1(stack["args"])
}

func (c *current) onparameters1(params any) (any, error) {

	return recursiveResolveIdentifiers(params), nil
}

func (p *parser) callonparameters1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onparameters1(stack["params"])
}

func (c *current) onfunction1(name, params, body any) (any, error) {

	return &ast.FunDeclaration{
		Name:       name.(ast.Identifier),
		Parameters: params.([]ast.Identifier),
		Body:       body.(*ast.BlockStatement),
	}, nil
}

func (p *parser) callonfunction1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfunction1(stack["name"], stack["params"], stack["body"])
}

func (c *current) onPrimary2() (any, error) {
	return ast.BooleanLiteral(true), nil
}

func (p *parser) callonPrimary2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrimary2()
}

func (c *current) onPrimary4() (any, error) {
	return ast.BooleanLiteral(false), nil
}

func (p *parser) callonPrimary4() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrimary4()
}

func (c *current) onPrimary6() (any, error) {
	return ast.Nil{}, nil
}

func (p *parser) callonPrimary6() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrimary6()
}

func (c *current) onPrimary8() (any, error) {
	return ast.This{}, nil
}

func (p *parser) callonPrimary8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrimary8()
}

func (c *current) onPrimary10(n any) (any, error) {
	return n, nil
}

func (p *parser) callonPrimary10() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrimary10(stack["n"])
}

func (c *current) onPrimary13(s any) (any, error) {
	return s, nil
}

func (p *parser) callonPrimary13() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrimary13(stack["s"])
}

func (c *current) onPrimary16(i any) (any, error) {
	return i, nil
}

func (p *parser) callonPrimary16() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrimary16(stack["i"])
}

func (c *current) onPrimary19(e any) (any, error) {

	return e, nil

}

func (p *parser) callonPrimary19() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrimary19(stack["e"])
}

func (c *current) onPrimary25(i any) (any, error) {

	return &ast.PropertyAccessExpression{
		Target:   ast.Super{},
		Property: i.(ast.Identifier),
	}, nil

}

func (p *parser) callonPrimary25() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrimary25(stack["i"])
}

func (c *current) onCall1(e, pat any) (any, error) {

	expr := e.(ast.Expression)
	for _, pattern := range pat.([]any) {
		list := pattern.([]any)
		switch list[0].(TokenKind) {
		case TokLeftParenthesis:
			expr = &ast.InvocationExpression{
				Callee:    expr,
				Arguments: list[1].([]ast.Expression),
			}
		case TokDot:
			expr = &ast.PropertyAccessExpression{
				Target:   expr,
				Property: list[1].(ast.Identifier),
			}
		default:
			panic("unreachable case in peg::grammar::Call")
		}
	}
	return expr, nil
}

func (p *parser) callonCall1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCall1(stack["e"], stack["pat"])
}

func (c *current) onUnary2(op, u any) (any, error) {

	var operator ast.UnaryOperator
	switch op.(TokenKind) {
	case TokBang:
		operator = ast.UopLogicalNot
	case TokMinus:
		operator = ast.UopNegate
	default:
		panic("unreachable case in peg::grammar::Unary")
	}
	return &ast.UnaryExpression{
		Operator: operator,
		Operand:  u.(ast.Expression),
	}, nil
}

func (p *parser) callonUnary2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUnary2(stack["op"], stack["u"])
}

func (c *current) onFactor1(l, pat any) (any, error) {

	expr := l.(ast.Expression)
	for _, p := range pat.([]any) {
		pattern := p.([]any)
		for i := 0; i < len(pattern); i += 2 {
			var operator ast.BinaryOperator
			switch pattern[i].(TokenKind) {
			case TokSlash:
				operator = ast.BinopDivide
			case TokStar:
				operator = ast.BinopMultiply
			default:
				panic("unreachable case in peg::grammar::Factor")
			}
			expr = &ast.BinaryExpression{
				Left:     expr,
				Operator: operator,
				Right:    pattern[i+1].(ast.Expression),
			}
		}
	}
	return expr, nil
}

func (p *parser) callonFactor1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFactor1(stack["l"], stack["pat"])
}

func (c *current) onTerm1(l, pat any) (any, error) {

	expr := l.(ast.Expression)
	for _, p := range pat.([]any) {
		pattern := p.([]any)
		for i := 0; i < len(pattern); i += 2 {
			var operator ast.BinaryOperator
			switch pattern[i].(TokenKind) {
			case TokMinus:
				operator = ast.BinopSubtract
			case TokPlus:
				operator = ast.BinopAdd
			default:
				panic("unreachable case in peg::grammar::Term")
			}
			expr = &ast.BinaryExpression{
				Left:     expr,
				Operator: operator,
				Right:    pattern[i+1].(ast.Expression),
			}
		}
	}
	return expr, nil
}

func (p *parser) callonTerm1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTerm1(stack["l"], stack["pat"])
}

func (c *current) onComparison1(l, pat any) (any, error) {

	expr := l.(ast.Expression)
	for _, p := range pat.([]any) {
		pattern := p.([]any)
		for i := 0; i < len(pattern); i += 2 {
			var operator ast.BinaryOperator
			switch pattern[i].(TokenKind) {
			case TokGreaterEqual:
				operator = ast.BinopGreaterEqual
			case TokLessEqual:
				operator = ast.BinopLessEqual
			case TokGreater:
				operator = ast.BinopGreater
			case TokLess:
				operator = ast.BinopLess
			default:
				panic("unreachable case in peg::grammar::Comparison")
			}
			expr = &ast.BinaryExpression{
				Left:     expr,
				Operator: operator,
				Right:    pattern[i+1].(ast.Expression),
			}
		}
	}
	return expr, nil
}

func (p *parser) callonComparison1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onComparison1(stack["l"], stack["pat"])
}

func (c *current) onEquality1(l, pat any) (any, error) {

	expr := l.(ast.Expression)
	for _, p := range pat.([]any) {
		pattern := p.([]any)
		for i := 0; i < len(pattern); i += 2 {
			var operator ast.BinaryOperator
			switch pattern[i].(TokenKind) {
			case TokBangEqual:
				operator = ast.BinopNotEqual
			case TokEqualEqual:
				operator = ast.BinopEqual
			default:
				panic("unreachable case in peg::grammar::Equality")
			}
			expr = &ast.BinaryExpression{
				Left:     expr,
				Operator: operator,
				Right:    pattern[i+1].(ast.Expression),
			}
		}
	}
	return expr, nil
}

func (p *parser) callonEquality1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEquality1(stack["l"], stack["pat"])
}

func (c *current) onLogicalAnd1(l, pat any) (any, error) {

	expr := l.(ast.Expression)
	for _, p := range pat.([]any) {
		pattern := p.([]any)
		for i := 0; i < len(pattern); i += 2 {
			expr = &ast.BinaryExpression{
				Left:     expr,
				Operator: ast.BinopLogicalAnd,
				Right:    pattern[i+1].(ast.Expression),
			}
		}
	}
	return expr, nil
}

func (p *parser) callonLogicalAnd1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLogicalAnd1(stack["l"], stack["pat"])
}

func (c *current) onLogicalOr1(l, pat any) (any, error) {

	expr := l.(ast.Expression)
	for _, p := range pat.([]any) {
		pattern := p.([]any)
		for i := 0; i < len(pattern); i += 2 {
			expr = &ast.BinaryExpression{
				Left:     expr,
				Operator: ast.BinopLogicalOr,
				Right:    pattern[i+1].(ast.Expression),
			}
		}
	}
	return expr, nil
}

func (p *parser) callonLogicalOr1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLogicalOr1(stack["l"], stack["pat"])
}

func (c *current) onAssignment2(prev, i, e any) (any, error) {

	var expr ast.Expression
	if prev != nil {
		previous := prev.([]any)
		expr = &ast.PropertyAccessExpression{
			Target:   previous[0].(ast.Expression),
			Property: i.(ast.Identifier),
		}
	} else {
		expr = i.(ast.Expression)
	}
	return &ast.AssignmentExpression{
		Target: expr,
		Value:  e.(ast.Expression),
	}, nil
}

func (p *parser) callonAssignment2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAssignment2(stack["prev"], stack["i"], stack["e"])
}

var (
	// errNoRule is returned when the grammar to parse has no rule.
	errNoRule = errors.New("grammar has no rule")

	// errInvalidEntrypoint is returned when the specified entrypoint rule
	// does not exit.
	errInvalidEntrypoint = errors.New("invalid entrypoint")

	// errInvalidEncoding is returned when the source is not properly
	// utf8-encoded.
	errInvalidEncoding = errors.New("invalid encoding")

	// errMaxExprCnt is used to signal that the maximum number of
	// expressions have been parsed.
	errMaxExprCnt = errors.New("max number of expressions parsed")
)

// Option is a function that can set an option on the parser. It returns
// the previous setting as an Option.
type Option func(*parser) Option

// MaxExpressions creates an Option to stop parsing after the provided
// number of expressions have been parsed, if the value is 0 then the parser will
// parse for as many steps as needed (possibly an infinite number).
//
// The default for maxExprCnt is 0.
func MaxExpressions(maxExprCnt uint64) Option {
	return func(p *parser) Option {
		oldMaxExprCnt := p.maxExprCnt
		p.maxExprCnt = maxExprCnt
		return MaxExpressions(oldMaxExprCnt)
	}
}

// Entrypoint creates an Option to set the rule name to use as entrypoint.
// The rule name must have been specified in the -alternate-entrypoints
// if generating the parser with the -optimize-grammar flag, otherwise
// it may have been optimized out. Passing an empty string sets the
// entrypoint to the first rule in the grammar.
//
// The default is to start parsing at the first rule in the grammar.
func Entrypoint(ruleName string) Option {
	return func(p *parser) Option {
		oldEntrypoint := p.entrypoint
		p.entrypoint = ruleName
		if ruleName == "" {
			p.entrypoint = g.rules[0].name
		}
		return Entrypoint(oldEntrypoint)
	}
}

// Statistics adds a user provided Stats struct to the parser to allow
// the user to process the results after the parsing has finished.
// Also the key for the "no match" counter is set.
//
// Example usage:
//
//	input := "input"
//	stats := Stats{}
//	_, err := Parse("input-file", []byte(input), Statistics(&stats, "no match"))
//	if err != nil {
//	    log.Panicln(err)
//	}
//	b, err := json.MarshalIndent(stats.ChoiceAltCnt, "", "  ")
//	if err != nil {
//	    log.Panicln(err)
//	}
//	fmt.Println(string(b))
func Statistics(stats *Stats, choiceNoMatch string) Option {
	return func(p *parser) Option {
		oldStats := p.Stats
		p.Stats = stats
		oldChoiceNoMatch := p.choiceNoMatch
		p.choiceNoMatch = choiceNoMatch
		if p.Stats.ChoiceAltCnt == nil {
			p.Stats.ChoiceAltCnt = make(map[string]map[string]int)
		}
		return Statistics(oldStats, oldChoiceNoMatch)
	}
}

// Debug creates an Option to set the debug flag to b. When set to true,
// debugging information is printed to stdout while parsing.
//
// The default is false.
func Debug(b bool) Option {
	return func(p *parser) Option {
		old := p.debug
		p.debug = b
		return Debug(old)
	}
}

// Memoize creates an Option to set the memoize flag to b. When set to true,
// the parser will cache all results so each expression is evaluated only
// once. This guarantees linear parsing time even for pathological cases,
// at the expense of more memory and slower times for typical cases.
//
// The default is false.
func Memoize(b bool) Option {
	return func(p *parser) Option {
		old := p.memoize
		p.memoize = b
		return Memoize(old)
	}
}

// AllowInvalidUTF8 creates an Option to allow invalid UTF-8 bytes.
// Every invalid UTF-8 byte is treated as a utf8.RuneError (U+FFFD)
// by character class matchers and is matched by the any matcher.
// The returned matched value, c.text and c.offset are NOT affected.
//
// The default is false.
func AllowInvalidUTF8(b bool) Option {
	return func(p *parser) Option {
		old := p.allowInvalidUTF8
		p.allowInvalidUTF8 = b
		return AllowInvalidUTF8(old)
	}
}

// Recover creates an Option to set the recover flag to b. When set to
// true, this causes the parser to recover from panics and convert it
// to an error. Setting it to false can be useful while debugging to
// access the full stack trace.
//
// The default is true.
func Recover(b bool) Option {
	return func(p *parser) Option {
		old := p.recover
		p.recover = b
		return Recover(old)
	}
}

// GlobalStore creates an Option to set a key to a certain value in
// the globalStore.
func GlobalStore(key string, value any) Option {
	return func(p *parser) Option {
		old := p.cur.globalStore[key]
		p.cur.globalStore[key] = value
		return GlobalStore(key, old)
	}
}

// InitState creates an Option to set a key to a certain value in
// the global "state" store.
func InitState(key string, value any) Option {
	return func(p *parser) Option {
		old := p.cur.state[key]
		p.cur.state[key] = value
		return InitState(key, old)
	}
}

// ParseFile parses the file identified by filename.
func ParseFile(filename string, opts ...Option) (i any, err error) { // nolint: deadcode
	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer func() {
		if closeErr := f.Close(); closeErr != nil {
			err = closeErr
		}
	}()
	return ParseReader(filename, f, opts...)
}

// ParseReader parses the data from r using filename as information in the
// error messages.
func ParseReader(filename string, r io.Reader, opts ...Option) (any, error) { // nolint: deadcode
	b, err := io.ReadAll(r)
	if err != nil {
		return nil, err
	}

	return Parse(filename, b, opts...)
}

// Parse parses the data from b using filename as information in the
// error messages.
func Parse(filename string, b []byte, opts ...Option) (any, error) {
	return newParser(filename, b, opts...).parse(g)
}

// position records a position in the text.
type position struct {
	line, col, offset int
}

func (p position) String() string {
	return strconv.Itoa(p.line) + ":" + strconv.Itoa(p.col) + " [" + strconv.Itoa(p.offset) + "]"
}

// savepoint stores all state required to go back to this point in the
// parser.
type savepoint struct {
	position
	rn rune
	w  int
}

type current struct {
	pos  position // start position of the match
	text []byte   // raw text of the match

	// state is a store for arbitrary key,value pairs that the user wants to be
	// tied to the backtracking of the parser.
	// This is always rolled back if a parsing rule fails.
	state storeDict

	// globalStore is a general store for the user to store arbitrary key-value
	// pairs that they need to manage and that they do not want tied to the
	// backtracking of the parser. This is only modified by the user and never
	// rolled back by the parser. It is always up to the user to keep this in a
	// consistent state.
	globalStore storeDict
}

type storeDict map[string]any

// the AST types...

// nolint: structcheck
type grammar struct {
	pos   position
	rules []*rule
}

// nolint: structcheck
type rule struct {
	pos         position
	name        string
	displayName string
	expr        any
}

// nolint: structcheck
type choiceExpr struct {
	pos          position
	alternatives []any
}

// nolint: structcheck
type actionExpr struct {
	pos  position
	expr any
	run  func(*parser) (any, error)
}

// nolint: structcheck
type recoveryExpr struct {
	pos          position
	expr         any
	recoverExpr  any
	failureLabel []string
}

// nolint: structcheck
type seqExpr struct {
	pos   position
	exprs []any
}

// nolint: structcheck
type throwExpr struct {
	pos   position
	label string
}

// nolint: structcheck
type labeledExpr struct {
	pos   position
	label string
	expr  any
}

// nolint: structcheck
type expr struct {
	pos  position
	expr any
}

type (
	andExpr        expr // nolint: structcheck
	notExpr        expr // nolint: structcheck
	zeroOrOneExpr  expr // nolint: structcheck
	zeroOrMoreExpr expr // nolint: structcheck
	oneOrMoreExpr  expr // nolint: structcheck
)

// nolint: structcheck
type ruleRefExpr struct {
	pos  position
	name string
}

// nolint: structcheck
type stateCodeExpr struct {
	pos position
	run func(*parser) error
}

// nolint: structcheck
type andCodeExpr struct {
	pos position
	run func(*parser) (bool, error)
}

// nolint: structcheck
type notCodeExpr struct {
	pos position
	run func(*parser) (bool, error)
}

// nolint: structcheck
type litMatcher struct {
	pos        position
	val        string
	ignoreCase bool
	want       string
}

// nolint: structcheck
type charClassMatcher struct {
	pos             position
	val             string
	basicLatinChars [128]bool
	chars           []rune
	ranges          []rune
	classes         []*unicode.RangeTable
	ignoreCase      bool
	inverted        bool
}

type anyMatcher position // nolint: structcheck

// errList cumulates the errors found by the parser.
type errList []error

func (e *errList) add(err error) {
	*e = append(*e, err)
}

func (e errList) err() error {
	if len(e) == 0 {
		return nil
	}
	e.dedupe()
	return e
}

func (e *errList) dedupe() {
	var cleaned []error
	set := make(map[string]bool)
	for _, err := range *e {
		if msg := err.Error(); !set[msg] {
			set[msg] = true
			cleaned = append(cleaned, err)
		}
	}
	*e = cleaned
}

func (e errList) Error() string {
	switch len(e) {
	case 0:
		return ""
	case 1:
		return e[0].Error()
	default:
		var buf bytes.Buffer

		for i, err := range e {
			if i > 0 {
				buf.WriteRune('\n')
			}
			buf.WriteString(err.Error())
		}
		return buf.String()
	}
}

// parserError wraps an error with a prefix indicating the rule in which
// the error occurred. The original error is stored in the Inner field.
type parserError struct {
	Inner    error
	pos      position
	prefix   string
	expected []string
}

// Error returns the error message.
func (p *parserError) Error() string {
	return p.prefix + ": " + p.Inner.Error()
}

// newParser creates a parser with the specified input source and options.
func newParser(filename string, b []byte, opts ...Option) *parser {
	stats := Stats{
		ChoiceAltCnt: make(map[string]map[string]int),
	}

	p := &parser{
		filename: filename,
		errs:     new(errList),
		data:     b,
		pt:       savepoint{position: position{line: 1}},
		recover:  true,
		cur: current{
			state:       make(storeDict),
			globalStore: make(storeDict),
		},
		maxFailPos:      position{col: 1, line: 1},
		maxFailExpected: make([]string, 0, 20),
		Stats:           &stats,
		// start rule is rule [0] unless an alternate entrypoint is specified
		entrypoint: g.rules[0].name,
	}
	p.setOptions(opts)

	if p.maxExprCnt == 0 {
		p.maxExprCnt = math.MaxUint64
	}

	return p
}

// setOptions applies the options to the parser.
func (p *parser) setOptions(opts []Option) {
	for _, opt := range opts {
		opt(p)
	}
}

// nolint: structcheck,deadcode
type resultTuple struct {
	v   any
	b   bool
	end savepoint
}

// nolint: varcheck
const choiceNoMatch = -1

// Stats stores some statistics, gathered during parsing
type Stats struct {
	// ExprCnt counts the number of expressions processed during parsing
	// This value is compared to the maximum number of expressions allowed
	// (set by the MaxExpressions option).
	ExprCnt uint64

	// ChoiceAltCnt is used to count for each ordered choice expression,
	// which alternative is used how may times.
	// These numbers allow to optimize the order of the ordered choice expression
	// to increase the performance of the parser
	//
	// The outer key of ChoiceAltCnt is composed of the name of the rule as well
	// as the line and the column of the ordered choice.
	// The inner key of ChoiceAltCnt is the number (one-based) of the matching alternative.
	// For each alternative the number of matches are counted. If an ordered choice does not
	// match, a special counter is incremented. The name of this counter is set with
	// the parser option Statistics.
	// For an alternative to be included in ChoiceAltCnt, it has to match at least once.
	ChoiceAltCnt map[string]map[string]int
}

// nolint: structcheck,maligned
type parser struct {
	filename string
	pt       savepoint
	cur      current

	data []byte
	errs *errList

	depth   int
	recover bool
	debug   bool

	memoize bool
	// memoization table for the packrat algorithm:
	// map[offset in source] map[expression or rule] {value, match}
	memo map[int]map[any]resultTuple

	// rules table, maps the rule identifier to the rule node
	rules map[string]*rule
	// variables stack, map of label to value
	vstack []map[string]any
	// rule stack, allows identification of the current rule in errors
	rstack []*rule

	// parse fail
	maxFailPos            position
	maxFailExpected       []string
	maxFailInvertExpected bool

	// max number of expressions to be parsed
	maxExprCnt uint64
	// entrypoint for the parser
	entrypoint string

	allowInvalidUTF8 bool

	*Stats

	choiceNoMatch string
	// recovery expression stack, keeps track of the currently available recovery expression, these are traversed in reverse
	recoveryStack []map[string]any
}

// push a variable set on the vstack.
func (p *parser) pushV() {
	if cap(p.vstack) == len(p.vstack) {
		// create new empty slot in the stack
		p.vstack = append(p.vstack, nil)
	} else {
		// slice to 1 more
		p.vstack = p.vstack[:len(p.vstack)+1]
	}

	// get the last args set
	m := p.vstack[len(p.vstack)-1]
	if m != nil && len(m) == 0 {
		// empty map, all good
		return
	}

	m = make(map[string]any)
	p.vstack[len(p.vstack)-1] = m
}

// pop a variable set from the vstack.
func (p *parser) popV() {
	// if the map is not empty, clear it
	m := p.vstack[len(p.vstack)-1]
	if len(m) > 0 {
		// GC that map
		p.vstack[len(p.vstack)-1] = nil
	}
	p.vstack = p.vstack[:len(p.vstack)-1]
}

// push a recovery expression with its labels to the recoveryStack
func (p *parser) pushRecovery(labels []string, expr any) {
	if cap(p.recoveryStack) == len(p.recoveryStack) {
		// create new empty slot in the stack
		p.recoveryStack = append(p.recoveryStack, nil)
	} else {
		// slice to 1 more
		p.recoveryStack = p.recoveryStack[:len(p.recoveryStack)+1]
	}

	m := make(map[string]any, len(labels))
	for _, fl := range labels {
		m[fl] = expr
	}
	p.recoveryStack[len(p.recoveryStack)-1] = m
}

// pop a recovery expression from the recoveryStack
func (p *parser) popRecovery() {
	// GC that map
	p.recoveryStack[len(p.recoveryStack)-1] = nil

	p.recoveryStack = p.recoveryStack[:len(p.recoveryStack)-1]
}

func (p *parser) print(prefix, s string) string {
	if !p.debug {
		return s
	}

	fmt.Printf("%s %d:%d:%d: %s [%#U]\n",
		prefix, p.pt.line, p.pt.col, p.pt.offset, s, p.pt.rn)
	return s
}

func (p *parser) printIndent(mark string, s string) string {
	return p.print(strings.Repeat(" ", p.depth)+mark, s)
}

func (p *parser) in(s string) string {
	res := p.printIndent(">", s)
	p.depth++
	return res
}

func (p *parser) out(s string) string {
	p.depth--
	return p.printIndent("<", s)
}

func (p *parser) addErr(err error) {
	p.addErrAt(err, p.pt.position, []string{})
}

func (p *parser) addErrAt(err error, pos position, expected []string) {
	var buf bytes.Buffer
	if p.filename != "" {
		buf.WriteString(p.filename)
	}
	if buf.Len() > 0 {
		buf.WriteString(":")
	}
	buf.WriteString(fmt.Sprintf("%d:%d (%d)", pos.line, pos.col, pos.offset))
	if len(p.rstack) > 0 {
		if buf.Len() > 0 {
			buf.WriteString(": ")
		}
		rule := p.rstack[len(p.rstack)-1]
		if rule.displayName != "" {
			buf.WriteString("rule " + rule.displayName)
		} else {
			buf.WriteString("rule " + rule.name)
		}
	}
	pe := &parserError{Inner: err, pos: pos, prefix: buf.String(), expected: expected}
	p.errs.add(pe)
}

func (p *parser) failAt(fail bool, pos position, want string) {
	// process fail if parsing fails and not inverted or parsing succeeds and invert is set
	if fail == p.maxFailInvertExpected {
		if pos.offset < p.maxFailPos.offset {
			return
		}

		if pos.offset > p.maxFailPos.offset {
			p.maxFailPos = pos
			p.maxFailExpected = p.maxFailExpected[:0]
		}

		if p.maxFailInvertExpected {
			want = "!" + want
		}
		p.maxFailExpected = append(p.maxFailExpected, want)
	}
}

// read advances the parser to the next rune.
func (p *parser) read() {
	p.pt.offset += p.pt.w
	rn, n := utf8.DecodeRune(p.data[p.pt.offset:])
	p.pt.rn = rn
	p.pt.w = n
	p.pt.col++
	if rn == '\n' {
		p.pt.line++
		p.pt.col = 0
	}

	if rn == utf8.RuneError && n == 1 { // see utf8.DecodeRune
		if !p.allowInvalidUTF8 {
			p.addErr(errInvalidEncoding)
		}
	}
}

// restore parser position to the savepoint pt.
func (p *parser) restore(pt savepoint) {
	if p.debug {
		defer p.out(p.in("restore"))
	}
	if pt.offset == p.pt.offset {
		return
	}
	p.pt = pt
}

// Cloner is implemented by any value that has a Clone method, which returns a
// copy of the value. This is mainly used for types which are not passed by
// value (e.g map, slice, chan) or structs that contain such types.
//
// This is used in conjunction with the global state feature to create proper
// copies of the state to allow the parser to properly restore the state in
// the case of backtracking.
type Cloner interface {
	Clone() any
}

var statePool = &sync.Pool{
	New: func() any { return make(storeDict) },
}

func (sd storeDict) Discard() {
	for k := range sd {
		delete(sd, k)
	}
	statePool.Put(sd)
}

// clone and return parser current state.
func (p *parser) cloneState() storeDict {
	if p.debug {
		defer p.out(p.in("cloneState"))
	}

	state := statePool.Get().(storeDict)
	for k, v := range p.cur.state {
		if c, ok := v.(Cloner); ok {
			state[k] = c.Clone()
		} else {
			state[k] = v
		}
	}
	return state
}

// restore parser current state to the state storeDict.
// every restoreState should applied only one time for every cloned state
func (p *parser) restoreState(state storeDict) {
	if p.debug {
		defer p.out(p.in("restoreState"))
	}
	p.cur.state.Discard()
	p.cur.state = state
}

// get the slice of bytes from the savepoint start to the current position.
func (p *parser) sliceFrom(start savepoint) []byte {
	return p.data[start.position.offset:p.pt.position.offset]
}

func (p *parser) getMemoized(node any) (resultTuple, bool) {
	if len(p.memo) == 0 {
		return resultTuple{}, false
	}
	m := p.memo[p.pt.offset]
	if len(m) == 0 {
		return resultTuple{}, false
	}
	res, ok := m[node]
	return res, ok
}

func (p *parser) setMemoized(pt savepoint, node any, tuple resultTuple) {
	if p.memo == nil {
		p.memo = make(map[int]map[any]resultTuple)
	}
	m := p.memo[pt.offset]
	if m == nil {
		m = make(map[any]resultTuple)
		p.memo[pt.offset] = m
	}
	m[node] = tuple
}

func (p *parser) buildRulesTable(g *grammar) {
	p.rules = make(map[string]*rule, len(g.rules))
	for _, r := range g.rules {
		p.rules[r.name] = r
	}
}

// nolint: gocyclo
func (p *parser) parse(g *grammar) (val any, err error) {
	if len(g.rules) == 0 {
		p.addErr(errNoRule)
		return nil, p.errs.err()
	}

	// TODO : not super critical but this could be generated
	p.buildRulesTable(g)

	if p.recover {
		// panic can be used in action code to stop parsing immediately
		// and return the panic as an error.
		defer func() {
			if e := recover(); e != nil {
				if p.debug {
					defer p.out(p.in("panic handler"))
				}
				val = nil
				switch e := e.(type) {
				case error:
					p.addErr(e)
				default:
					p.addErr(fmt.Errorf("%v", e))
				}
				err = p.errs.err()
			}
		}()
	}

	startRule, ok := p.rules[p.entrypoint]
	if !ok {
		p.addErr(errInvalidEntrypoint)
		return nil, p.errs.err()
	}

	p.read() // advance to first rune
	val, ok = p.parseRuleWrap(startRule)
	if !ok {
		if len(*p.errs) == 0 {
			// If parsing fails, but no errors have been recorded, the expected values
			// for the farthest parser position are returned as error.
			maxFailExpectedMap := make(map[string]struct{}, len(p.maxFailExpected))
			for _, v := range p.maxFailExpected {
				maxFailExpectedMap[v] = struct{}{}
			}
			expected := make([]string, 0, len(maxFailExpectedMap))
			eof := false
			if _, ok := maxFailExpectedMap["!."]; ok {
				delete(maxFailExpectedMap, "!.")
				eof = true
			}
			for k := range maxFailExpectedMap {
				expected = append(expected, k)
			}
			sort.Strings(expected)
			if eof {
				expected = append(expected, "EOF")
			}
			p.addErrAt(errors.New("no match found, expected: "+listJoin(expected, ", ", "or")), p.maxFailPos, expected)
		}

		return nil, p.errs.err()
	}
	return val, p.errs.err()
}

func listJoin(list []string, sep string, lastSep string) string {
	switch len(list) {
	case 0:
		return ""
	case 1:
		return list[0]
	default:
		return strings.Join(list[:len(list)-1], sep) + " " + lastSep + " " + list[len(list)-1]
	}
}

func (p *parser) parseRuleMemoize(rule *rule) (any, bool) {
	res, ok := p.getMemoized(rule)
	if ok {
		p.restore(res.end)
		return res.v, res.b
	}

	startMark := p.pt
	val, ok := p.parseRule(rule)
	p.setMemoized(startMark, rule, resultTuple{val, ok, p.pt})

	return val, ok
}

func (p *parser) parseRuleWrap(rule *rule) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseRule " + rule.name))
	}
	var (
		val       any
		ok        bool
		startMark = p.pt
	)

	if p.memoize {
		val, ok = p.parseRuleMemoize(rule)
	} else {
		val, ok = p.parseRule(rule)
	}

	if ok && p.debug {
		p.printIndent("MATCH", string(p.sliceFrom(startMark)))
	}
	return val, ok
}

func (p *parser) parseRule(rule *rule) (any, bool) {
	p.rstack = append(p.rstack, rule)
	p.pushV()
	val, ok := p.parseExprWrap(rule.expr)
	p.popV()
	p.rstack = p.rstack[:len(p.rstack)-1]
	return val, ok
}

func (p *parser) parseExprWrap(expr any) (any, bool) {
	var pt savepoint

	if p.memoize {
		res, ok := p.getMemoized(expr)
		if ok {
			p.restore(res.end)
			return res.v, res.b
		}
		pt = p.pt
	}

	val, ok := p.parseExpr(expr)

	if p.memoize {
		p.setMemoized(pt, expr, resultTuple{val, ok, p.pt})
	}
	return val, ok
}

// nolint: gocyclo
func (p *parser) parseExpr(expr any) (any, bool) {
	p.ExprCnt++
	if p.ExprCnt > p.maxExprCnt {
		panic(errMaxExprCnt)
	}

	var val any
	var ok bool
	switch expr := expr.(type) {
	case *actionExpr:
		val, ok = p.parseActionExpr(expr)
	case *andCodeExpr:
		val, ok = p.parseAndCodeExpr(expr)
	case *andExpr:
		val, ok = p.parseAndExpr(expr)
	case *anyMatcher:
		val, ok = p.parseAnyMatcher(expr)
	case *charClassMatcher:
		val, ok = p.parseCharClassMatcher(expr)
	case *choiceExpr:
		val, ok = p.parseChoiceExpr(expr)
	case *labeledExpr:
		val, ok = p.parseLabeledExpr(expr)
	case *litMatcher:
		val, ok = p.parseLitMatcher(expr)
	case *notCodeExpr:
		val, ok = p.parseNotCodeExpr(expr)
	case *notExpr:
		val, ok = p.parseNotExpr(expr)
	case *oneOrMoreExpr:
		val, ok = p.parseOneOrMoreExpr(expr)
	case *recoveryExpr:
		val, ok = p.parseRecoveryExpr(expr)
	case *ruleRefExpr:
		val, ok = p.parseRuleRefExpr(expr)
	case *seqExpr:
		val, ok = p.parseSeqExpr(expr)
	case *stateCodeExpr:
		val, ok = p.parseStateCodeExpr(expr)
	case *throwExpr:
		val, ok = p.parseThrowExpr(expr)
	case *zeroOrMoreExpr:
		val, ok = p.parseZeroOrMoreExpr(expr)
	case *zeroOrOneExpr:
		val, ok = p.parseZeroOrOneExpr(expr)
	default:
		panic(fmt.Sprintf("unknown expression type %T", expr))
	}
	return val, ok
}

func (p *parser) parseActionExpr(act *actionExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseActionExpr"))
	}

	start := p.pt
	val, ok := p.parseExprWrap(act.expr)
	if ok {
		p.cur.pos = start.position
		p.cur.text = p.sliceFrom(start)
		state := p.cloneState()
		actVal, err := act.run(p)
		if err != nil {
			p.addErrAt(err, start.position, []string{})
		}
		p.restoreState(state)

		val = actVal
	}
	if ok && p.debug {
		p.printIndent("MATCH", string(p.sliceFrom(start)))
	}
	return val, ok
}

func (p *parser) parseAndCodeExpr(and *andCodeExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseAndCodeExpr"))
	}

	state := p.cloneState()

	ok, err := and.run(p)
	if err != nil {
		p.addErr(err)
	}
	p.restoreState(state)

	return nil, ok
}

func (p *parser) parseAndExpr(and *andExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseAndExpr"))
	}

	pt := p.pt
	state := p.cloneState()
	p.pushV()
	_, ok := p.parseExprWrap(and.expr)
	p.popV()
	p.restoreState(state)
	p.restore(pt)

	return nil, ok
}

func (p *parser) parseAnyMatcher(any *anyMatcher) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseAnyMatcher"))
	}

	if p.pt.rn == utf8.RuneError && p.pt.w == 0 {
		// EOF - see utf8.DecodeRune
		p.failAt(false, p.pt.position, ".")
		return nil, false
	}
	start := p.pt
	p.read()
	p.failAt(true, start.position, ".")
	return p.sliceFrom(start), true
}

// nolint: gocyclo
func (p *parser) parseCharClassMatcher(chr *charClassMatcher) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseCharClassMatcher"))
	}

	cur := p.pt.rn
	start := p.pt

	// can't match EOF
	if cur == utf8.RuneError && p.pt.w == 0 { // see utf8.DecodeRune
		p.failAt(false, start.position, chr.val)
		return nil, false
	}

	if chr.ignoreCase {
		cur = unicode.ToLower(cur)
	}

	// try to match in the list of available chars
	for _, rn := range chr.chars {
		if rn == cur {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	// try to match in the list of ranges
	for i := 0; i < len(chr.ranges); i += 2 {
		if cur >= chr.ranges[i] && cur <= chr.ranges[i+1] {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	// try to match in the list of Unicode classes
	for _, cl := range chr.classes {
		if unicode.Is(cl, cur) {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	if chr.inverted {
		p.read()
		p.failAt(true, start.position, chr.val)
		return p.sliceFrom(start), true
	}
	p.failAt(false, start.position, chr.val)
	return nil, false
}

func (p *parser) incChoiceAltCnt(ch *choiceExpr, altI int) {
	choiceIdent := fmt.Sprintf("%s %d:%d", p.rstack[len(p.rstack)-1].name, ch.pos.line, ch.pos.col)
	m := p.ChoiceAltCnt[choiceIdent]
	if m == nil {
		m = make(map[string]int)
		p.ChoiceAltCnt[choiceIdent] = m
	}
	// We increment altI by 1, so the keys do not start at 0
	alt := strconv.Itoa(altI + 1)
	if altI == choiceNoMatch {
		alt = p.choiceNoMatch
	}
	m[alt]++
}

func (p *parser) parseChoiceExpr(ch *choiceExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseChoiceExpr"))
	}

	for altI, alt := range ch.alternatives {
		// dummy assignment to prevent compile error if optimized
		_ = altI

		state := p.cloneState()

		p.pushV()
		val, ok := p.parseExprWrap(alt)
		p.popV()
		if ok {
			p.incChoiceAltCnt(ch, altI)
			return val, ok
		}
		p.restoreState(state)
	}
	p.incChoiceAltCnt(ch, choiceNoMatch)
	return nil, false
}

func (p *parser) parseLabeledExpr(lab *labeledExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseLabeledExpr"))
	}

	p.pushV()
	val, ok := p.parseExprWrap(lab.expr)
	p.popV()
	if ok && lab.label != "" {
		m := p.vstack[len(p.vstack)-1]
		m[lab.label] = val
	}
	return val, ok
}

func (p *parser) parseLitMatcher(lit *litMatcher) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseLitMatcher"))
	}

	start := p.pt
	for _, want := range lit.val {
		cur := p.pt.rn
		if lit.ignoreCase {
			cur = unicode.ToLower(cur)
		}
		if cur != want {
			p.failAt(false, start.position, lit.want)
			p.restore(start)
			return nil, false
		}
		p.read()
	}
	p.failAt(true, start.position, lit.want)
	return p.sliceFrom(start), true
}

func (p *parser) parseNotCodeExpr(not *notCodeExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseNotCodeExpr"))
	}

	state := p.cloneState()

	ok, err := not.run(p)
	if err != nil {
		p.addErr(err)
	}
	p.restoreState(state)

	return nil, !ok
}

func (p *parser) parseNotExpr(not *notExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseNotExpr"))
	}

	pt := p.pt
	state := p.cloneState()
	p.pushV()
	p.maxFailInvertExpected = !p.maxFailInvertExpected
	_, ok := p.parseExprWrap(not.expr)
	p.maxFailInvertExpected = !p.maxFailInvertExpected
	p.popV()
	p.restoreState(state)
	p.restore(pt)

	return nil, !ok
}

func (p *parser) parseOneOrMoreExpr(expr *oneOrMoreExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseOneOrMoreExpr"))
	}

	var vals []any

	for {
		p.pushV()
		val, ok := p.parseExprWrap(expr.expr)
		p.popV()
		if !ok {
			if len(vals) == 0 {
				// did not match once, no match
				return nil, false
			}
			return vals, true
		}
		vals = append(vals, val)
	}
}

func (p *parser) parseRecoveryExpr(recover *recoveryExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseRecoveryExpr (" + strings.Join(recover.failureLabel, ",") + ")"))
	}

	p.pushRecovery(recover.failureLabel, recover.recoverExpr)
	val, ok := p.parseExprWrap(recover.expr)
	p.popRecovery()

	return val, ok
}

func (p *parser) parseRuleRefExpr(ref *ruleRefExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseRuleRefExpr " + ref.name))
	}

	if ref.name == "" {
		panic(fmt.Sprintf("%s: invalid rule: missing name", ref.pos))
	}

	rule := p.rules[ref.name]
	if rule == nil {
		p.addErr(fmt.Errorf("undefined rule: %s", ref.name))
		return nil, false
	}
	return p.parseRuleWrap(rule)
}

func (p *parser) parseSeqExpr(seq *seqExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseSeqExpr"))
	}

	vals := make([]any, 0, len(seq.exprs))

	pt := p.pt
	state := p.cloneState()
	for _, expr := range seq.exprs {
		val, ok := p.parseExprWrap(expr)
		if !ok {
			p.restoreState(state)
			p.restore(pt)
			return nil, false
		}
		vals = append(vals, val)
	}
	return vals, true
}

func (p *parser) parseStateCodeExpr(state *stateCodeExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseStateCodeExpr"))
	}

	err := state.run(p)
	if err != nil {
		p.addErr(err)
	}
	return nil, true
}

func (p *parser) parseThrowExpr(expr *throwExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseThrowExpr"))
	}

	for i := len(p.recoveryStack) - 1; i >= 0; i-- {
		if recoverExpr, ok := p.recoveryStack[i][expr.label]; ok {
			if val, ok := p.parseExprWrap(recoverExpr); ok {
				return val, ok
			}
		}
	}

	return nil, false
}

func (p *parser) parseZeroOrMoreExpr(expr *zeroOrMoreExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseZeroOrMoreExpr"))
	}

	var vals []any

	for {
		p.pushV()
		val, ok := p.parseExprWrap(expr.expr)
		p.popV()
		if !ok {
			return vals, true
		}
		vals = append(vals, val)
	}
}

func (p *parser) parseZeroOrOneExpr(expr *zeroOrOneExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseZeroOrOneExpr"))
	}

	p.pushV()
	val, _ := p.parseExprWrap(expr.expr)
	p.popV()
	// whether it matched or not, consider it a match
	return val, true
}
